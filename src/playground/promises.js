
// -- Mark 1 --
// lecture 144: ES6 Promises
// the easiest way to explore the promises API is create our own promise and start messing
// around it

// we going to set the const promise equal to a new Promise using the new keyword with the
// Promise constructor function and we do have to pass in an arrow function as the argument
// and inside the function we do our long running asynchronous task so maybe were making a
// request to a server or trying to trigger a Firebase data change or were looking for a
// file in the file system or were trying to take a picture with a webcam and when it is
// done we call one of 2 functions depending on whether it went well or whether it did
// not go well and those 2 functions are resolve and reject and we pass them into the
// arrow function as arguments and if we call resolve it means hey this thing went well
// and we got the data or whatever we happened to be doing and if we call reject it will
// alert us that something did go wrong and here is the error
const promise = new Promise( ( resolve, reject ) => {
    // so at this point we are going to ignore a lot of the details and call resolve and we will
    // pass in anything we like and in this case, we will pass in a string " This is my resolved
    // data " and so at this point we have a completely valid promise that we can start using

    // -- Mark 2 --
    // lecture 144: ES6 Promises
    // call setTimeout and add in our resolve() call and now we will see a delay between when this
    // code run and when it prints to the console
    setTimeout( () => {
        resolve( 'This is my resolved data' );
        // END OF -- Mark 2 --
        // go to -- Mark 3 -- below

        // -- Mark 5 --
        // lecture 144: ES6 Promises
        // call resolve again and pass in some data and when we do this we might think the callback
        // below would run twice, right? but this does not happen because the promise API was not
        // designed for this since our promise is either resolved or rejected and when it is
        // resolved or rejected it can never be resolved or rejected again which means that the
        // below resolve will be completely ignored and this is exactly what happens when go to
        // the console and view the messages or in other words " This is my other resolved data. "
        // never shows up

        // also, it is important to note that we can only pass a single argument to resolve or
        // reject so we could not pass in another string as a second argument like " other " or
        // we can't do this: " resolve( 'This is my resolved data', 'other' ); " and if we need
        // to do need more than one piece of information go ahead and pass in an object or
        // do something like this:
        /*
        resolve({
            name : 'Andrew',
            age  : 26
        })
        */
        // and now we will have access to both of those key values pairs on the data argument below
        resolve( 'This is my other resolved data.' );
        // END OF -- Mark 5 --
        // go to -- Mark 6 -- below 
    }, 5000 )
});

// most of the time these promises are going to be created for us which means were really not
// going to see this kind of code a whole lot in our projects and code like this lives inside
// the Firebase library and what we are going to be doing is using a lot of promises or
// using promises that are generated by method calls like set() so when we have a promise,
// how do we know if it succeeds or fails? we can find this out by accessing a promise and then
// registering some callbacks

// -- Mark 3 --
// lecture 144: ES6 Promises
console.log( 'before' );
// END OF -- Mark 3 --
// go to -- Mark 4 -- below

// .then() let's us register a callback and that callback will fire when and if the promise
// resolves and we will pass an arrow function into .then() and we will have access to any data
// that was passed to resolve() above and we can represent this data as an argument to the arrow
// function and we will call the argument " data " which represents any data that was passed to
// resolve() above and then for testing purposes let's log that data out by using console.log()
promise.then( ( data ) => {
    console.log( '1', data );
})


// so at this point, we have created a promise that resolves some data or:
/*
const promise = new Promise( ( resolve, reject ) => {
    resolve( 'This is my resolved data' );
});
*/

// and we have also waited for things to complete or:
/*
promise.then( ( data ) => {
    console.log( data );
})
*/
// and when they do complete all we do is dump the data to the screen and now save the file and
// go to our expensify app and take a look at the output in the console and we see that we get
// our message being printed to the console or: " This is my resolved data " so the data is flowing
// correctly but it is not the most meaningful thing in the world so let's go ahead and make this
// example a little more real world and so to simulate some sort of arbitary delay we are going to
// be using setTimeout so were going to force the promise to wait a 5 seconds before it
// actually resolves so let's add setTimeout above
// go to -- Mark 2 -- above

// -- Mark 4 --
// lecture 144: ES6 Promises
console.log( 'after' );

// if we go to the console, we see:
// first: " before "
// second: " after "
// third: " This is my resolved data "

// so what is going on here? first up, our console.log run and prints " before " to the screen and
// we say hey when this promise completes after 5 seconds go ahead and this function:
/*
promise.then( ( data ) => {
    console.log( data );
})
*/

// but it is not going to wait for the promise to complete and will move on to the next 
// console.log() call and print " after " and then after 5 seconds our promise does resolve and
// then our function right above does fire so using this technique were going to be able to do all
// sorts of interesting things especially with Firebase, for example, were going to be able to fetch
// data and wait for the data to come back and then do something with the data and the same thing is
// true when writing data, for example, we can start the process of writing the data and then do
// something when Firebase says yes the data was written successfully

// if we wanted to we could add another promise down below so we could take the one from above and copy it
// and then paste it down below and now we are attaching 2 callbacks and both callbacks say hey run
// me when the data comes back adn let's add a first argument to both functions ( i.e. '2' below )
// so we can see when each one runs 
promise.then( ( data ) => {
    console.log( '2', data );
})

// the one thing to note is that a promise can be either resolved or rejected and can't resolve and
// reject a promise and you can only resolve or reject a single time so now let's add another call 
// above
// END OF -- Mark 4 --
// go to -- Mark 5 -- above


// -- Mark 6 --
// lecture 144: ES6 Promises
// resolve an object
// remember, have to name this promise something different than the promise up above
const promise2 = new Promise( ( resolve, reject ) => {
    setTimeout( () => {
        resolve( {
            name : 'Andrew',
            age  : 26
        } );
    }, 7500 )
});

promise2.then( ( data ) => {
    console.log( '3', data );
})

// our console now looks as follows:
/*
before
after
1 This is my resolved data
2 This is my resolved data
3 {name: "Andrew", age: 26}
*/

// now at this point, we have only resolved a promise and when we resolve a promise we are saying
// hey the thing we expected to happen it happened or you say you wanted to fetch the weather from
// this API and the weather was fetched but things do go wrong and when things go wrong we use
// reject

// now let's do another promise where we use reject and reject follows the same rules as resolve
// such as you can only call it a single time and you can only call it with a single argument so
// let's go ahead and call reject with an error and we will use a string error message " Somthing
// went wrong "
const promise3 = new Promise( ( resolve, reject ) => {
    setTimeout( () => {
        reject( 'Something went wrong!' );
    }, 8500 )
});

promise3.then( ( data ) => {
    console.log( '3', data );
}).catch( ( error ) => {
    console.log( 'error: ', error );
} );

// what happens after 8.5 seconds? we'll we do not get our console.log message instead we get an
// because console.log only fires when the promise gets resolved instead what we are getting is
// an actual JavaScript error or: " Uncaught (in promise) Something went wrong! " so we do have
// our error message but we also have an uncaught JavaScript error and we don't want a whole bunch
// of JavaScipt errors being thrown instead we want to do something specific when that happens,
// for example, maybe we want to try the request again or show an error message to the user so we
// want to actually do something when our promise gets rejected and that something is to add
// .catch() to the end of .then() or promise.then().catch() and catch is very similar to then in
// that it gets called with a single function or an arrow function and this function fires when
// the promise rejects and we do get access to that rejection data and we can access this data
// through the argument and in this case we'll call our argument " error " although we could call
// the argument anything we like and now we can do something with the error inside the arrow
// fucntion such as we could try the request again or we could print the error message to the
// user in the browser but for now we are just going to console.log the error message and dump
// the error message to the screen

// now let's see what happens?
// our console now looks as follows:
/*
before
after
1 This is my resolved data
2 This is my resolved data
3 {name: "Andrew", age: 26}
error:  Something went wrong!
*/

// so we have our error message printing to the screen because we set up our catch handler above
// set up and ready to catch errors so we now have a way to do something when the promise resolves
// and when the promise rejects and this is exactly what were hoping to do with our Firebase data

// now before we go, there are a lot of alternatives to the promise syntax and our instructor wants
// to show us a couple real quick and the first alternative is that then() can take 2 arguments
// or functions and they can be used in lieu of catch and if you pass a second argument into then
// this second argument will be treated as your catch handler, for example, see below:
/*
promise3.then( ( data ) => {
    console.log( '3', data );
}, ( error ) => {
    console.log( 'error: ', error );
} );
*/

// instructor likes using the then and catch better than using 2 arguments for then and so now we
// know the basics of promises and as the instructor mentioned before, about 99% of the time, when
// we are working with promises we are going to be working with this side of things, see below for
// an example:
/*
promise3.then( ( data ) => {
    console.log( '3', data );
}).catch( ( error ) => {
    console.log( 'error: ', error );
} );
*/

// and very rarely will we find outselves creating our own promises, like the one below:
/*
const promise = new Promise( ( resolve, reject ) => {
    setTimeout( () => {
        resolve( 'This is my resolved data' );
        resolve( 'This is my other resolved data.' );
    }, 5000 )
});
*/

// and most of the time promises are going to be created by the library you are using, for example,
// like a library like Firebase and what were going to do is attach handlers, things to run when
// the promise either resolves or rejects and to wrap this video, we want to go ahead and create a
// promise for our firebase.js file but first remove the import or
// " import './playground/promises'; " from app.js and then let's go to our firebase.js file

// inside our firebase.js file, we are going to try to add a then and catch method call onto one of
// the promises in the file and the question is where is our promise? and what exactly should we be
// calling then and catch on? and this is the topic of the next video

// END OF -- Mark 6 --



// -- Mark 7 --
// lecture 153: Testing Async Redux Actions: Part 1
// we can chain promises and let's add on a second then() call and what is going to happen when we
// add the second then() call? first, the promise is either going to resolve or reject and if it
// resolves then the first then callback will fire and it will print 4 to screen with the data
// and then it will run the second then() callback and print " Does this run? " to the console and
// the answer is yes, this is going to run and now test this and
// go to -- app.js -- and import in this file by typing " import './playrgound/promises'; " and then
// go to the console in the expensify app and make sure the first and second then calls ran
// correctly

// have to first create the promise and then below we will consume the promise
const promise4 = new Promise( ( resolve, reject ) => {
    setTimeout( () => {
        resolve( {
            name : 'Sara',
            age  : 46
        } );
    }, 15000 )
});

// now consume the promise
promise4.then( ( data ) => {

    console.log( '4', data );

}).then( () => {

    console.log( 'Does this run?' );

}).catch( ( error ) => {

    console.log( 'error : ', error );

});

// now let's see what happens?
// our console now looks as follows:
/*
before
after
1 This is my resolved data
2 This is my resolved data
3 {name: "Andrew", age: 26}
error:  Something went wrong!
4 {name: "Sara", age: 46}
Does this run?
*/


// the second then() call does not get any data passed to it unless we return some data
// inside the first then() callback and let's test this out below and prove that we can pass
// data from one success callback to another success callback

// have to first create the promise and then below we will consume the promise
const promise5 = new Promise( ( resolve, reject ) => {
    setTimeout( () => {
        resolve( {
            name : 'Joe',
            age  : 56
        } );
    }, 15000 )
});

// now consume the promise
promise5.then( ( data ) => {

    console.log( '5', data );
    return 'some data';

}).then( ( data ) => {

    console.log( 'Does this run?', data );

}).catch( ( error ) => {

    console.log( 'error : ', error );

});


// now let's see what happens?
// our console now looks as follows:
/*
before
after
1 This is my resolved data
2 This is my resolved data
3 {name: "Andrew", age: 26}
error:  Something went wrong!
4 {name: "Sara", age: 46}
Does this run?
5 {name: "Joe", age: 56}
Does this run? some data
*/


// so it worked, we were able to pass data from one success callback to another success callback
// and by using this core feature of promises were going to be able to correctly run our assertions
// in the test file in expenses.test.js so let's
// go to -- app.js -- and remove the playground/promises.js import since we no longer need this
// import in app.js since we just wanted to see promise chaining in action and then
// go to -- tests/actions/expenses.test.js -- and continue working on test case #5


// END OF -- Mark 7 --



// -- Mark 8 --
// lecture 154: Testing Async Redux Actions: Part 2
// first, make sure this file actually runs by importing this file in app.js and in promise5 above
// we returned " some data " in the second then() callback but we can also return a promise and if
// we return a promise then the next then() callback is that promise's success case and let's test
// this out

// first create the promise and then below we will consume the promise
const promise6 = new Promise( ( resolve, reject ) => {
    setTimeout( () => {
        resolve( {
            name : 'Mike',
            age  : 80
        } );
    }, 17500 )
});

// now consume the promise
// and in promise6, let's add in a new promise called promise7 as shown below and the second then()
// callback will only run once promise7 resolves and save this file and go to the expensify app
// console to see if promise 6 and 7 ran correctly
promise6.then( ( data ) => {

    console.log( '6', data );

    // the promise below ( we'll refer to it as promise7 ) will get started as soon as promise6
    // resolves so promise7 will get started after 17.5 seconds and then will resolve after
    // 4 seconds ( see setTimeout below ) so being able to return promises inside other promises
    // and then chain that promise onto the next then() callback
    // will allow us to reduce the need for those nested callbacks that were getting in the
    // actions/expenses.js file and let's go ahead and integrate this techinique into our code
    // and once again, let's remove " import './playground/promises'; " from app.js and
    // go to -- Mark 3 -- in the actions/expenses.test.js file
    return new Promise( ( resolve, reject ) => {
        setTimeout( () => {
            resolve( 'This is promise7 inside promise6' );
        }, 4000 )
    });

}).then( ( data ) => {

    console.log( 'Did promise7 run?', data );

}).catch( ( error ) => {

    console.log( 'error : ', error );

});


// our console now looks as follows:
/*
before
after
1 This is my resolved data
2 This is my resolved data
3 {name: "Andrew", age: 26}
error:  Something went wrong!
4 {name: "Sara", age: 46}
Does this run?
5 {name: "Joe", age: 56}
Does this run? some data
6 {name: "Mike", age: 80}
Did promise7 run? This is promise7 inside promise6
*/


// END OF -- Mark 8 --

