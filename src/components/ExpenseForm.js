
// -- Mark 1 --
import React from 'react';
// -- Mark 2 --
import moment from 'moment';
// import the named export from the react-dates library
import { SingleDatePicker } from 'react-dates';
// import the css for the react-dates library
import 'react-dates/lib/css/_datepicker.css';


// let's play around with moment
// we know we could create a new date object by typing the below
// but the API is terrible so we will be using moment instead
// and moment is the standard for dates
// const date = new Date();

// to use moment, type the below and what we get back is an instance
// of moment and the date variable below represents the current period in time
const date = moment();
// console.log( date );
// to get the date, use the format method
// can put a comma after the day below and that's Ok
// we need to be able to work with moment objects being generated by other
// libraries like react-dates
console.log( date.format( 'MMM Do, YYYY' ) );

// let's go ahead and use the SingleDatePicker component and all react-dates
// components have required props and the docs show you what those required
// props are
// go to -- Mark 3 -- below

// ----------------------------




// -- Mark 1 --
// create a basic component and get it rendered in AddExpensePage

// we have our 4 expense form fields: description, note, amount and
// createdAt but were not going to worry about createdAt in this video
// and will tackle createdAt in its own video later

// the big picture goal here is to use local component state to track
// the changes to all the inputs below and only when the user submits the
// form will we actually do something with that information
// so were going to keep track of the changes to every single input and
// when the user submits the form then we will we send that information off
// to redux to either edit an existing expense or create a new expense

// to introduce local component state, set up a state object below
export default class ExpenseForm extends React.Component {
    // -- Mark 6 --
    // if an expense was passed down we need start description, note, amount and
    // createdAt at those values and we can't do that using the state = {} syntax
    // so we have to define our state in the constructor function in order to access
    // the props
    // so we pass the props to the constructor function and then pass them up to super
    // and then we will define this.state

    // the constructor function gets called with a props object and props in the constructor
    // function is exactly the same as the this.props in the render() method
    // then we have to call super( props ) to make sure props gets set and if we don't call
    // super( props ) were not going to have access to this.props
    constructor( props ) {
        super( props );

        // -- Mark 6 --
        // if an expense was passed down we need start description, note, amount and
        // createdAt at those values and we can do that by using the ternary operator
        // so if props.expense exist then use relevant value, otherwise use the
        // default value as the value
        // ( i.e. this.props.description ? this.props.description : '', )
        // so now when we click an expense ( which has already been created ) on the
        // Dashboard page, it will direct us to the Edit expense page and we will see
        // all the field populated with the correct values from the clicked expense
        // ------------
        this.state = {
            // the user will need to add an expense description
            description : props.expense ? props.expense.description : '',
            // the number will start off at zero and the note will be
            // optional
            // STEP 1: in the render method below, set the value to the
            // current state value or this.state.description and this will
            // create a read only value which is not what we want
            // so add an onChange handler so the user can change the description
            // and we will reference an arrow function that we create below

            // challange
            // set up note state and onChange and value for the textarea
            note : props.expense ? props.expense.note : '',

            // next, for amount we are going to limit the user to just using numbers
            // and we are going to allow for a decimal place but we are going to enforce
            // how many numbers you can have after the decimal place so to make this happen
            // we are going to use a little conditional logic in our amount onChange handler
            // and we want to allow the user to enter at most 2 numbers after the decimal
            // point and to make this work we have to change type="number" to type="text"
            // and add in our own validation code

            // below add in value={ this.state.amount } and onChange={ this.onAmountChange }
            // next, go to onAmountChange
            amount : props.expense ? ( props.expense.amount / 100 ).toString() : '',

            // createdAt will represent the current moment in time
            // -- Mark 6 --
            // if an expense exist, we want to make sure we create an instance of moment
            // at a specific point in time or when this expense was orginally created 
            // not just when the code runs, which is what moment() shows so we type
            // " moment( props.expense.createdAt ) "
            // -----------

            // ==============================
            // GO TO EDITEXPENSEPAGE.JS -- Mark 6 --
            // ==============================

            createdAt : props.expense ? moment( props.expense.createdAt ) : moment(),

            // start focused off as not focused so set focused equal to false
            calenderFocused : false,

            // error
            error : ''
        };
    }

    // -- Mark 4 --
    onSubmit = ( e ) => {
        // first, prevent a full page refresh
        e.preventDefault();

        // error handing
        // we are going to be providing a little bit of validation and we want to validate
        // description and amount
        // if there is no description or there is no amount, we want to render an error to
        // the screen
        if ( !this.state.description || !this.state.amount ) {
            // Error message will read: " Please provide description and / or amount. "
            // challange
            // wire up the error handling
            this.setState( ( ) => ( {
                error : ' Please provide description and / or amount. ' 
            } ) );
        }
        else {
            // here we clear the error
            this.setState( ( ) => ( {
                error : '' 
            } ) );

            // -- Mark 5 --
            // we just passed down onSubmit from the AddExpensePage component
            // and we are going to call it with some data in the form of an object
            this.props.onSubmit({
                description : this.state.description,
                note        : this.state.note,
                // for amount, we need to convert in into cents or the format we expect
                amount      : parseFloat( this.state.amount ) * 100,
                // createdAt is not the timestamp we expect but is a moment object but we
                // can use moment method to get the timestamp back and that method is
                // valueOf() and remember js works in milliseconds
                createdAt   : this.state.createdAt.valueOf()
            });

            // so there is nothing left for the ExpenseForm component to do
            // the AddExpensePage component needs to be able to dispatch the given action
            // to the redux store
            
            // ------------

            // ==============================
            // GO TO ADDEXPENSEPAGE.JS -- Mark 5 --
            // ==============================
        }

    };

    // ------------

    onDescriptionChange = ( e ) => {
        const description = e.target.value;
        // we do not need the previous state argument for this function
        // call this.setState and pass in the updater function
        // witihn an arrow function we can return an object but we have to put the object
        // in parentheses ()

        // if we test this in the react tab under dev tools, we can see the state change as
        // we enter values in the description input field
        this.setState( ( ) => ( {
            description : description
        } ) );
    };

    onAmountChange = ( e ) => {
        const amount = e.target.value;

        // now to make sure the user follows a specified format, we will use an if statement
        // and regular expressions
        // use regex101.com to create your regular expression
        // so if the amount value above matches the regular expression then we have a truthy
        // value and we will proceed into the if statement

        // so if there is a match we will set the state otherwise we will not set the state
        // and if the user can not set the state then nothing will happen inside the input
        // field when the user types in the characters or in other words the characters
        // will be ignored inside the input field so the user can only type the characters
        // that will match our regular expression below
        // so this will ensure that the number is typed into the input field in a specific
        // format

        // in the next video, we changed ( amount.match( /^\d{1,}(\.\d{0,2})?$/ ) ) to
        // ( !amount || amount.match( /^\d{1,}(\.\d{0,2})?$/ ) ) so that we can delete
        // every character in the input field and start over
        if ( !amount || amount.match( /^\d{1,}(\.\d{0,2})?$/ ) ) {

            // we do not need the previous state argument for this function
            // call this.setState and pass in the updater function
            // witihn an arrow function we can return an object but we have to put the object
            // in parentheses ()

            // if we test this in the react tab under dev tools, we can see the state change as
            // we enter values in the description input field
            this.setState( ( ) => ( {
                amount : amount
            } ) );
        }

    };

    // in the api for onDateChange, the arrow function argument is the current moment in time
    // this handler is very similar to our other handlers but this one gets called by the 3rd
    // party library or react-dates
    onDateChange = ( createdAt ) => {
        // all we have to do inside the arrow function is use this.setState() and set the state
        // for createdAt

        // we do not need the previous state argument for this function
        // call this.setState and pass in the updater function
        // witihn an arrow function we can return an object but we have to put the object
        // in parentheses ()
        this.setState( () => ( {
            createdAt : createdAt
        } ) );
    };

    // in the api for onFocusChange, the first argument is an object and library is destructuring
    // it and grabbing the focused property and then setting that property on the state
    // so we can use it as follows and " focused " below represents true or false
    onFocusChange = ( { focused } ) => {
        // all we have to do inside the arrow function is use this.setState() and set the state
        // for calenderFocused

        // we do not need the previous state argument for this function
        // call this.setState and pass in the updater function
        // witihn an arrow function we can return an object but we have to put the object
        // in parentheses ()
        this.setState( () => ( {
            // we are going to set calenderFocused equal to whatever value came back from
            // " focused "
            calenderFocused : focused
        } ) );
    };

    onNoteChange = ( e ) => {
        const note = e.target.value;
        // we do not need the previous state argument for this function
        // call this.setState and pass in the updater function
        // witihn an arrow function we can return an object but we have to put the object
        // in parentheses ()

        // if we test this in the react tab under dev tools, we can see the state change as
        // we enter values in the description input field
        this.setState( ( ) => ( {
            note : note
        } ) );

        // way #2 for setState
        // this.setState( ( ) => ( {
        //    note
        // } ) );         
    };
    
    // see -- Mark 3 -- below ( <SingleDatePicker /> ) and provide the 4 required props
    // the date prop is a moments object that represents the time you want to start and for
    // out purposes we want to use the current time
    // the onDateChange prop will be a function that will get called with a moment instance
    // when someone picks a new day from the calender
    // now, we are going to mess around with a couple of the options available to us with
    // <SingleDatePicker />
    // the first option we are going to configure is the number of months that are shown
    // with the date picker and check the documentation
    // the second option we are going to configure is the ability to select days in the
    // past and will use the isOutsideRange prop and this prop takes a function and we
    // are going to define that function inline and the argument is " day " and is useful
    // for a lodging application where you only want to show days where you have a vacancy
    // but for our purposes we don't care what the day is, we always want the or any
    // " day " to be available and to make this happen we just leave out the argument
    // and return false

    // now, at this point all of our component state values are being tracked or in other
    // words, the description, amount, calender and note are being changed in real time
    // the only thing left to do to get this data saved is to dispatch an action when
    // the form is submitted and were goint to handle that in the next video

    // recap: in this video, we installed moments.js and moments is a great time
    // utility library and react-dates is a calender picker tool that happens to
    // require the momentjs library
    // with a date picker, we have to provide with an initial value and we did that
    // above with " createdAt : moment(), ", which gives createdAt the current time value
    // and we then dump that current time into the date picker and we then track changes
    // to the date and focus and lastly we provided some customization by defining the
    // number of months to show and what dates are visible and therefore selectable in
    // the date picker

    // --------------

    // -- Mark 4 --
    // add the onSubmt prop below
    // display the error message below and use the logical && operator to do so
    // from MDN: " Logical AND (&&)  expr1 && expr2  If expr1 can be converted to true,
    // returns expr2; else, returns expr1. "

    // where do we dispatch the action?
    // we are not going to dispatch the action in this component since we want this
    // component to be reusable so we pass the onSubmit prop up to the AddExpensePage
    // component and dispatch there

    //------------

    // ==============================
    // GO TO ADDEXPENSEPAGE.JS -- Mark 4 --
    // ==============================

    render() {
        return (
            <div>
                { this.state.error  && <p>{ this.state.error }</p> }
                <form onSubmit={ this.onSubmit }>
                    <input
                        type       ="text"
                        placeholder="Description"
                        autoFocus
                        value      ={ this.state.description }
                        onChange   ={ this.onDescriptionChange }
                    />
                    <input
                        type       ="text"
                        placeholder="Amount"
                        value      ={ this.state.amount }
                        onChange   ={ this.onAmountChange }
                    />
                    <SingleDatePicker
                        date          ={ this.state.createdAt }
                        onDateChange  ={ this.onDateChange }
                        focused       ={ this.state.calenderFocused }
                        onFocusChange ={ this.onFocusChange }
                        numberOfMonths={ 1 }
                        isOutsideRange={ () => false }
                    />
                    <textarea
                        placeholder="Add a note for your expense (optional)"
                        value      ={ this.state.note }
                        onChange   ={ this.onNoteChange }
                    ></textarea>
                    <button>Add Expense</button>
                </form>
            </div>
        );
    }
}



// ==============================
// GO TO ADDEXPENSEPAGE.JS -- Mark 3 --
// ==============================